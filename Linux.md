# Linux学习笔记

## 基础知识

### 超频
  将 CPU 的倍频或者是外频透过主板的设定功能更改成较高频率的一种方式。但因为
  CPU 的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的为外频

### 超线程 (Hyper-Threading, HT)
  在每一个CPU内部将重要的缓存器 (register) 分成两群，而让程序分别使用这两群缓存器。也就是说，可以有两个程序『同时竞争 CPU 的运算单元』，而非透过操作系统的多任务切换！ 

  
### 多通道设计
由于所有的数据都必须要存放在主存储器，所以主存储器的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达 64 位，为了要加大这个宽度，因此芯片组厂商就将两个主存储器汇整在一起， 如果一支内存可达 64 位，两支内存就可以达到 128 位了，这就是双通道的设计理念。（可理解为计组的位扩展）


### 文件权限
          文件    目录
  r   4   读权限  权限
  w   2   写权限  修改档名
  x   1   执行权  访问权限


### 用户与组
  useradd
  passwdadd
  userdel
  usermod
  
  groupadd

  cat /etc/passwd   查看用户
  cat /etc/group    查看用户组



### umask 
  文件创建的权限默认最大为 666
  目录创建的权限默认最大为 777
  umaske的分数指的时 ** 默认值需要减掉的权限 **

  实际创建时 文件/目录 的权限为 当前默认权限 - umask

  例 ： 777 - 022

  root 默认 umask为 0022  （第一个0为特殊权限）
  普通用户 默认 umask为 0002


### 磁盘分区
  查看所有磁盘列表
  `` lsblk ``

  查看指定磁盘的分区类型和分区信息
  `` parted 磁盘目录（/dev/vda） print``





### 挂载
 Linux 系统中使用硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。
如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。

*** 挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。***

由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。




### 软硬连接的区别
  - 软连接，其实就是新建立一个文件，这个文件就是专门用来指向别的文件的（那就和windows 下的快捷方式的那个文件有很接近的意味）。软链接产生的是一个新的文件，但这个文件的作用就是专门指向某个文件的，删了这个软连接文件，那就等于不需要这个连接，和原来的存在的实体原文件没有任何关系，但删除原来的文件，则相应的软连接不可用（cat那个软链接文件，则提示“没有该文件或目录“）

  - 硬连接是不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。相反是软连接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软连接将变得毫无意义。而硬链接删除的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收。因此文件的内容不会被删除。

  - 硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件。可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件；而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。

  - 软链接可以跨文件系统，硬链接不可以；

  - 软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）；

  - 软链接可以对目录进行连接，硬链接不可以。

  - 两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。

  - 使用 -s 开关可以创建软链接。


### 数据流重导向
    可近似理解为管道
    
    stdin   < 文件输入  << 代表结束的输入符号

    例如： << "eof" 当键盘输入eof,此处输入就结束

    stdout  > 覆盖输出  >> 累加输出
    stderr  2>          2>>     
 
 ### '|' 管线命令
    - 管线命令仅会处理 standard output，对于 standard error output 会予以忽略
    - 管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。


### xargs 命令
xargs是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。

xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。

``` 
find /sbin -perm +700 |ls -l       #这个命令是错误的
find /sbin -perm +700 |xargs ls -l   #这样才是正确的
 ```

### 判断符号 []
使用 '[]' 必须要注意中括号的两端需要有空格符来分隔!
[ "${var}" == "100" ]
 ↑                 ↑

### if
    ↓
  if []; then
  elif []; then
  else
  fi

  注意空格和缩减！


### switch

case "${var}" in 
    condition 1)
                ;;
    condition 2)
                ;;
    condition 3)
                ;;      
esac


 ### loop

#### while until 循环
    while [  ]
    do
    done

    until []
    do
    done

    与C不同,是 '[]' 不是 '()',且 while 与 [] 有空格

    变量比较时,采用 "$[var]" 

    until 与 while 的条件互为可逆条件

    -lt => <
    -gt => >
    -le => <=
    -gr => >=


    for $var in list
    do

    done

    for ((i=0;i<n;i++))
    do

    done
    

### shell编程中的变量名问题

    在编写shell script过程中发现，当变量进行比较时，统一写为
    "${var}" 形式，意义上是取其值作为比较
    而若是 var 中存储的是文件路径，要将其作为命令执行的目录时，要以
    ${var} or $var 形式调用，否则无法正常使用
    ps. 也不可直接用 var，否则将以变量名var作为目标路径

    ```
      #!/bin/bash

      dir=/Tdir/test
      mkdir $dir

    ```

### 用户组
  将一个已有用户增加到一个已有用户组中，使此用户组成为该用户的附加用户组，可以使用带 -a 参数的 usermod  指令。-a 代表 append， 也就是将用户添加到新用户组中而不必离开原有的其他用户组。不过需要与 -G 选项配合使用：
  `` usermod -a -G root dpanda ``

  如果要同时将 dpanda 的主要用户组改为 root，则直接使用 -g 选项：
  `` usermod -g apache cnzhx ``

  如果要将一个用户从某个组中删除，则
  `` gpasswd -d user group ``

  但是这个时候需要保证 group 不是 user 的主组。

  锁定用户
  passwd -l usr
  解锁
  passwd -u usr

  #### 删除用户组失败？
  必须要确认 /etc/passwd 内的账号没有任何人使用该群组作为初始用户组（initial group）。


  #### 用户权限问题
  只要root才可进行useradd,userdel,usedmod等操作
  因为 /etc/passwd /etc/shadow 的权限为 -rw-r--r--
  所以普通用户无法修改它们的内容，也即无法添加、修改、删除用户

  #### 为什么 root 无法以 telnet 直接登入系统，但是却能够使用 ssh 直接登入？

  telnet 会引用 login 的 PAM 模块，而 login 的验证阶段会有 /etc/securetty 的限制！ 由于远程联机属于 pts/n (n 为数字) 的动态终端机接口装置名称，并没有写入到 /etc/securetty ， 因此 root 无法以 telnet 登入远程主机。至于 ssh 使用的是 /etc/pam.d/sshd 这个模块， 你可以查阅一下该模块，由于该模块的验证阶段并没有加入 pam_securetty ，因此就没有 /etc/securetty 的限制！故可以从远程直接联机到服务器端。


  #### 如何禁用某个账户
  1. 锁定用户
    passwd -l usr
    解锁
    passwd -u usr
  
  2. 将 /etc/shadow 该用户的密码字段前加一个 '!' 或 '*'，使其无法登录
  
  3. 将 /etc/shadow 账号失效字段设定为当前日期，使其无法登录


  ### LVM (Logical Volume Manager)
  通过软件将磁盘整合成一块看起来独立的大磁盘(VG),经过分区(LV),最终即可挂载使用。

  PV  =>  经软件处理后的硬件磁盘
  VG  =>  将PV整合起来的虚拟内存
  PE  =>  LVM的最小的储存区块，用户可自定义
  LV  =>  虚拟分区


  ### 进程管理
    #### 后台运行
    command &
    
    运行状态下 ctrl+Z

    进程前后台运作

    fg %jobnum    将后台运行的进程调到前台
    bg %jobnum    让后台进程开始运行


    #### 结束进程
    kill -9   强制结束异常进程
    kill -15  正常结束进



    #### 2>&1
    /dev/null 表示空设备文件
    0 表示stdin标准输入
    1 表示stdout标准输出
    2 表示stderr标准错误

    ``nohup java -jar app.jar >log 2>&1 &``
    本来1----->屏幕 （1指向屏幕）
    执行>log后， 1----->log (1指向log)
    执行2>&1后， 2----->1 (2指向1，而1指向log,因此2也指向了log)

    #### ps
    1) ps a 显示现行终端机下的所有程序，包括其他用户的程序。
    2) ps -A 显示所有程序。 
    3) ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 
    4) ps -e 此参数的效果和指定"A"参数相同。 
    5) ps e 列出程序时，显示每个程序所使用的环境变量。 
    6) ps f 用ASCII字符显示树状结构，表达程序间的相互关系。 
    7) ps -H 显示树状结构，表示程序间的相互关系。 
    8) ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。 
    9) ps s 采用程序信号的格式显示程序状况。 
    10) ps S 列出程序时，包括已中断的子程序资料。 
    11) ps -t 　指定终端机编号，并列出属于该终端机的程序的状况。 
    12) ps u 　以用户为主的格式来显示程序状况。 
    13) ps x 　显示所有程序，不以终端机来区分。
    ps是显示当前状态处于running的进程，grep表示在这些里搜索，而ps aux是显示所有进程和其状态。

    $ ps aux | grep amoebap


#### 动态与静态链接库

   静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。


    1 静态链接库的优点 

     (1) 代码装载速度快，执行速度略比动态链接库快； 

     (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 

    2 动态链接库的优点 

     (1) 更加节省内存并减少页面交换；

     (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；

     (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；

     (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。