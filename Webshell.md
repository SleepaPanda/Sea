# Webshell

## webshell的定义

WebShell就是**以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境**，也可以将其称之为一种网页后门。攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，**得到一个命令执行环境，以达到控制网站服务器的目的**（可以上传下载或者修改文件，操作数据库，执行任意命令等）。

## 

### 常见的webshell一句话木马

https://blog.csdn.net/weixin_39190897/article/details/86772765

Get Shell

1. 目标文章存在文件上传漏洞
2. 执行文件上传操作，使用Burp Suite进行拦截，得到浏览器发送的请求
3. 将POST/GET请求发送到Reapter，修改请求的文件名和文件内容，绕过前端检测，发送一句话木马
4. 若文件上传失败，试从后缀名，木马书写格式，脚本等方面着手修改，再次尝试
5. 若文件上传成功，分析是否能从网页获取木马存储路径，获取完整路径后在浏览器访问木马网址，若访问成功进行下一步
6. 将木马网址复制到  antSword，填写主机地址：目标地址，填写密码： $POST['key'] 中的 key值，进行远程连接，若连接成功则可通过虚拟终端进行操作





### 绕过前端MIME的方法

​		Burp Suite 抓包，重写请求模拟正常POST/GET请求。



### 绕过后端文件检测

#### 简单绕过

##### 1.文件内容检测	--->	改变书写格式	

```php+HTML
<?php ?>
<? ?>
<script language="php"> </script> 
```



##### 2.黑名单检测	--->	改变文件后缀

​	.php	--->	.pphphp	.PHP	pHP5	php6



##### 3. asp漏洞

​	1)假设当前有一个名为"xxx.asp"的目录，那么该目录下的所有文件都将被作为asp文件解析

​	2)假设上传一个名为"test.asp;xxx.jpg"时，该文件会被当做asp文件解析



##### 4.检测文件头判断文件类型	--->	添加文件头

​	此时虽然检查的也是文件类型，但是是使用`getimagesize()`函数来获取文件的MIME类型，此时检测的不是数据包中的`content-type`，而是图片的文件头，常见的图片文件头如下：

> gif(GIF89a) : 47 49 46 38 39 61
>
> jpg、jpeg : FF D8 FF
>
> png : 89 50 4E 47 0D 0A

​	当上传php文件时，可以使用**winhex**、**010editor**等十六进制处理工具，在数据最前面添加图片的文件头，从而绕过检测



##### 5. 图片二次渲染	--->	将一句话木马添加到图片数据中伪装

​	检测机制是后端调用了php的GD库，提取了文件中的图片数据，然后再重新渲染，这样图片中插入的恶意代码就会被过滤掉了。

​	解决方法是：把木马插入到图片数据中，这样经过渲染后这部分数据还是会保留下来



#### 复杂绕过

##### 1. 白名单检测	--->	利用.htaccess解析

> htaccess文件(或者"分布式配置文件"）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。

​	上传一个 .htaccess文件	

​	P.S.	.htaccess 即使大小写不同也可执行！e.g. .hTaccess

​	配置方式

```
<FilesMatch "test.jpg">
  SetHandler application/x-httpd-php
</FilesMatch>
```

​	然后再上传一个 test.jpg 内容替换为木妈



##### 2. 木马免杀

​	1) 构造函数

```php
 # <?php $password = "LandGrey";array_udiff_assoc(array($_REQUEST[$password]), array(1), "assert");?>
     
#<?php/** * Noticed: (PHP 5 >= 5.3.0, PHP 7) * */$password = "LandGrey";$wx = substr($_SERVER["HTTP_REFERER"],-7,-4);forward_static_call_array($wx."ert", array($_REQUEST[$password]));?>   
```



## 反弹shell

反弹shell（reverse shell），就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。

 

**为什么要反弹shell？**

通常用于被控端因防火墙受限、权限不足、端口被占用等情形。

举例：攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是正向连接。远程桌面、web服务、ssh、telnet等等都是正向连接。什么情况下正向连接不能用了呢？

1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。 

2.目标机器的ip动态改变，你不能持续控制。

3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。

4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机等情况都是未知的，所以建立一个服务端让恶意程序主动连接，才是上策。

那么反弹就很好理解了，攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。

